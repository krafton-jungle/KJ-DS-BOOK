# 이진 검색 트리

---

## 1. 개념

이진 검색 트리*Binary Search Tree*는 이름 그대로 이진 트리의 일종으로, 임의의 노드가 왼쪽과 오른쪽의 자식 노드를 갖는 트리 구조를 이룬다.
이진 검색 트리의 특성은 다음과 같다.

> ---
>
> 임의의 한 노드 `x` 에 대해, `y`가 `x`의 왼쪽 서브 트리에 속하는 노드라면 `y ≤ x`를 만족한다. 그리고 `y`가 `x`의 오른쪽 서브 트리에 속하는 노드라면 `y ≥ x`를 만족한다.
>
> ---

이진 검색 트리의 특성은 재귀적으로 적용된다. 즉, 이진 검색 트리의 서브 트리 역시 이진 검색 트리의 특성을 만족한다.
이진 검색 트리의 특성을 이용하면 재귀적으로 중위 트리 순회*inorder tree walk* 알고리즘을 이용하여 이진 검색 트리의 모든 값을 정렬된 순으로 출력할 수 있다. 중위 트리 순회는 왼쪽 서브 트리, 루트, 오른쪽 서브 트리 순으로 방문하는 알고리즘이다.

---

## 2. 구현

### 2.1 기본 구조 - 노드와 초기화

이진 검색 트리는 이진 트리의 일종이므로, 각 노드를 객체로 하는 연결 자료구조로 표현될 수 있다.
노드 객체 `Node`는 데이터값을 저장하는 `data`와 각각 왼쪽, 오른쪽 자식을 가리키는 `left`와 `right` 필드와 부모 노드를 가리키는 `parent` 필드를 가진다. `left`, `right`, `parent`는 초기화 시 비어 있다는 의미로 `None`을 가지며, 삽입 및 삭제 과정을 통해 적절하게 변경된다.
트리 객체 `BinarySearchTree`는 초기화 시 입력받은 값을 가지는 노드를 루트로 하는 트리를 생성한다. 루트 노드는 부모 노드가 없으므로 `parent` 필드는 `None`으로 유지된다.

### 2.2 트리 순회

이진 검색 트리의 특성을 이용하여 트리의 모든 값을 정렬된 순서로 출력할 수 있다. 중위 트리 순회 프로시저를 재귀적으로 호출하여 모든 노드를 방문하는 것이 가능하다. 왼쪽-루트-오른쪽 순으로 방문 시 오름차순으로, 오른쪽-루트-왼쪽 순으로 방문 시 내림차순으로 출력할 수 있다.
초기의 호출 이후 이 프로시저는 트리의 각 노드에 대해 왼쪽 자식에 한 번, 오른쪽 자식에 한 번 총 두 번의 자기 호출을 하므로 $n$개의 노드로 이루어진 이진 검색 트리를 순회의 수행 시간은 $Θ(n)$ 이다.

### 2.3 검색

이진 검색 트리에서 특정 값 `value`를 검색하는 것은 루트에서 검색을 시작해 단순 경로 하나를 따라가는 것으로 이루어진다. 만나게 되는 각 노드 `current_node`의 값에 대해 `value`와 비교하여 `current_node`의 값이 더 클 경우 왼쪽 서브 트리로 진행, 작을 경우 오른쪽 서브 트리로 진행, 같은 경우 탐색을 종료한다. 탐색이 더 필요한 경우, 즉 특정 값을 아직 찾지 못한 경우 서브 트리에 대해 재귀적으로 프로시저를 호출한다.
재귀를 통해 트리의 루트에서 시작되는 단순 경로를 따라가는 탐색이 이루어지므로 트리의 높이를 $h$라 하면 이진 검색 트리 검색의 수행 시간은 $O(h)$ 이다.

### 2.4 최소, 최대 값

이진 검색 트리에서 최소, 최대 값을 찾는 것은 탐색 대상 트리의 루트에서 시작하여 왼쪽, 오른쪽 자식 노드를 따라가는 것으로 이루어진다. 왼쪽, 오른쪽 자식 노드가 존재하지 않을 때까지 탐색을 진행한 후, 존재하지 않는 경우 현재 노드의 값을 반환한다.
이진 검색 트리의 재귀적인 특성을 이용하여 특정 값의 직전, 직후 원소를 구하는데 최소, 최대 값 프로시저를 사용할 수 있다.

### 2.5 직전, 직후 값

이진 검색 트리에서 특정 값의 직전, 직후 값을 구하는 것은 이진 검색 트리의 구조를 이용하면 값을 전부 비교하지 않아도 가능하다.

> ---
>
> * 직전 값
> 왼쪽 서브 트리가 있을 경우 직전 값은 왼쪽 서브 트리의 가장 오른쪽 노드, 즉 서브 트리의 최댓값이 되고, 왼쪽 서브 트리가 없을 경우 직전 값은 해당 노드의 조상 노드를 따라 올라가는 중 특정 값보다 작아질 때의 값이다.
> * 직후 값
> 오른쪽 서브 트리가 있을 경우 직후 값은 오른쪽 서브 트리의 가장 왼쪽 노드, 즉 서브 트리의 최솟값이 되고, 오른쪽 서브 트리가 없을 경우 직후 값은 해당 노드의 조상 노드를 따라 올라가는 중 특정 값보다 커질 때의 값이다.
>
> ---

직전, 직후 값을 구하는 프로시저는 특정 노드로부터 트리를 따라 올라가거나 내려가는 단순 경로를 이용하므로 트리의 높이를 $h$라 하면 수행 시간은 $O(h)$ 이다. 특정 값의 직후 값을 구하는 프로시저는 트리에서 노드를 삭제하는 데에 이용된다.

### 2.6 삽입

이진 검색 트리에 값을 삽입하는 것은 검색과 마찬가지로 트리의 루트에서 시작해 단순 경로를 따라가는 것으로 이루어진다. 삽입하려는 값 `value`와 만나게 되는 각 노드 `current_node`의 값을 비교하여 왼쪽, 오른쪽 서브 트리로 진행하면서 더 이상 진행이 불가능한 경우, 즉 `current_node`에게 진행하려는 방향의 서브 트리가 없을 경우 `value`를 값으로 가지는 새 `Node` 객체를 생성하여 그 방향의 자식 노드로 넣는다. 새 노드는 `parent`를 `current_node`로 갖게 된다.
이진 검색 트리의 다른 기본 연산과 마찬가지로 단순 경로를 따라가는 탐색이 이루어지므로 트리의 높이를 $h$라 하면 이진 검색 트리 삽입의 수행 시간은 $O(h)$ 이다.

### 2.7 삭제

이진 검색 트리에서 노드를 삭제하는 경우는 세 가지로 나뉜다.

> ---
>
> * 대상 노드 `n`이 자식 노드를 가지고 있지 않은 경우
> `n`의 부모 노드, 즉 `parent`가 `n`을 가리키고 있던 필드를 `None`으로 대체한다.
> * 대상 노드 `n`이 자식 노드를 하나 가지고 있는 경우
> 자식 노드 `x`를 `n`이 있던 자리로 옮긴다. 즉, `n`의 `parent`가 `n`를 가리키고 있던 필드(`left` 또는 `right`)를 `x`로 대체한다.
> * 대상 노드 `n`이 자식 노드를 좌, 우 둘 다 가지고 있는 경우
> `n`의 직후 노드 `y`를 찾아 `n`의 자리로 옮긴다. `n`에게 자식 노드가 둘 있었으므로 `y`는 항상 `n`의 오른쪽 서브 트리에 존재한다. `n`의 오른쪽 서브 트리에 남은 노드들은 `y`의 새로운 오른쪽 서브 트리가, `n`의 왼쪽 서브 트리는 `y`의 새로운 왼쪽 서브 트리가 된다.
>
>---

서브 트리의 최솟값을 찾는 프로시저를 제외하면 삭제의 각 프로시저는 상수 시간을 소모한다. 그러므로 트리의 높이를 $h$라 하면 이진 검색 트리 삭제의 수행 시간은 $O(h)$ 이다.

---

## 3. 요약

### 3.1 핵심 속성

> ---
>
> 이진 탐색 트리의 각 노드는 최대 두 개의 자식 노드를 가지고, 다음과 같은 조건을 재귀적으로 만족한다.
>
> * 왼쪽 서브 트리에는 해당 노드보다 작은 값들만 존재한다.
> * 오른쪽 서브 트리에는 해당 노드보다 큰 값들만 존재한다.
>
> ---
>
> * 트리가 균형을 이룬 경우 $n$개의 값을 갖는 트리의 높이 $h$는 $log n$이다.
> * 균형이 잡힌 이진 검색 트리에서 검색, 삽입, 삭제 등의 핵심 프로시저는 $O(log n)$의 시간복잡도를 갖는다.
>
> ---

### 3.2 장점

> ---
>
> * 데이터가 트리 구조로 저장되어 있어 빠른 탐색이 가능하다.
> * 데이터에 중복이 없을 시 더욱 효율적으로 동작한다.
> * 중위 순회를 통해 정렬된 결과를 얻을 수 있다.
>
> ---

### 3.3 주의할 점

> ---
>
> * 트리가 균형을 잃었을 시, 즉 편향된*skewed* 트리가 되었을 경우 탐색 시간이 증가한다.
> * 편향된 트리가 되었을 경우 탐색 시간은 선형 검색과 동일한 $O(n)$이다.
>
> ---
