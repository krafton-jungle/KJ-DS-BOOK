# 배열 (Array)

## 개념

> <strong>배열(array)</strong>은 같은 자료형의 여러 데이터를 <strong>연속된 메모리 공간</strong>에 저장하고, 각 데이터를 <strong>인덱스(index)</strong>를 통해 접근할 수 있도록 구성된 자료구조다. 배열을 사용하면 비슷한 종류의 여러 변수를 하나로 묶어 관리할 수 있으므로, 코드의 **가독성**, **유지보수성**, **처리 효율성**이 크게 향상된다.

## 배열 선언 및 초기화 (C 언어 기준)

```c
// 선언과 동시에 초기화
int arr[5] = {10, 20, 30, 40, 50};

// 선언 후 개별 초기화
int arr[5];
arr[0] = 10;
arr[1] = 20;
// ...
```

> 배열의 크기는 반드시 상수로 선언해야 하며, 배열의 인덱스는 항상 0부터 시작한다.

## 주요 특징

- **정적 메모리 할당**  
  배열의 크기는 선언 시 고정되며, 실행 중에는 크기를 변경할 수 없다.  
  _(단, `malloc` 등을 사용하는 동적 배열은 예외)_

- **빠른 접근 속도**  
  배열은 인덱스를 사용하여 임의 위치의 요소에 **상수 시간(`O(1)`)**에 접근할 수 있다.

- **연속된 메모리 공간**  
  배열의 모든 요소는 메모리 상에 **연속적으로 저장**되어 있어, 캐시 효율이 높고 처리 속도가 빠르다.

- **단일 자료형만 저장 가능**  
  배열은 같은 자료형의 요소만 저장할 수 있으며, 서로 다른 타입을 저장하려면 구조체(struct)나 포인터 배열 등의 대안이 필요하다.

## 단점

- **크기 고정**  
  배열의 크기가 고정되어 있어, 저장할 요소의 수를 미리 예측하지 못하면 **메모리 낭비** 또는 **공간 부족** 문제가 발생할 수 있다.

- **삽입 및 삭제 비효율**  
  배열의 중간에 데이터를 삽입하거나 삭제하면, 해당 위치 이후의 모든 요소를 이동시켜야 하므로 <strong>시간 복잡도가 O(n)</strong>이다.

- **배열 경계 초과 위험**  
  유효한 인덱스 범위를 초과한 접근은 <strong>정의되지 않은 동작(undefined behavior)</strong>을 유발할 수 있다.

```c
int arr[5] = {0};
arr[5] = 100; // ❌ 오류: 유효한 인덱스는 0~4
```

---

## 배열의 메모리 구조 이해하기

> 아래 예시는 정수형 배열 `arr[5]`에 값들이 저장되어 있는 상황을 시각적으로 나타낸 것이다.

```lua
배열 이름: arr
인덱스:     0     1     2     3     4
          +-----+-----+-----+-----+-----+
arr[i] =  | 10  | 20  | 30  | 40  | 50  |
          +-----+-----+-----+-----+-----+
메모리 주소: A   A+4  A+8  A+12 A+16
```

`arr`는 **정수형(int)** 배열이며, 일반적으로 정수형 데이터는 **4바이트**를 차지한다. 배열의 요소들은 **연속된 메모리 공간**에 저장되며, 배열의 첫 번째 요소(`arr[0]`)가 위치한 주소를 `A`라고 가정할 때, 이후 요소들의 주소는 다음과 같이 계산된다:

```c
arr[i]의 주소 = A + (i × sizeof(int))
             = A + (i × 4)
```

이 구조 덕분에 배열은 특정 인덱스의 요소를 **주소 계산만으로 빠르게 접근**할 수 있다. 이는 내부적으로 **포인터 연산과 동일한 방식**으로 처리된다.

---

## 배열과 포인터의 관계

C 언어에서 배열과 포인터는 밀접한 관계가 있으며, 배열 이름은 암묵적으로 배열의 첫 번째 요소의 주소로 변환된다.

```c
int arr[5] = {10, 20, 30, 40, 50};

// 다음은 동일한 의미를 가진다
arr[2]     == *(arr + 2)
```

> 단, 배열과 포인터는 개념적으로는 다르며, 배열은 크기가 고정된 메모리 블록인 반면, 포인터는 가리키는 대상이 동적으로 변경될 수 있다.

---

## 배열이 적합한 상황

배열은 다음과 같은 경우에 유용하게 사용된다:

- 고정된 개수의 데이터를 처리할 때 (예: 학생 점수 30개)
- 반복문을 통해 데이터를 순차적으로 처리할 때
- 데이터가 모두 같은 자료형이며 구조가 단순할 때
- 메모리 접근 속도가 중요할 때

---

## 요약

| 장점                          | 단점                           |
| ----------------------------- | ------------------------------ |
| 빠른 접근 속도 (`O(1)`)       | 크기 고정                      |
| 메모리 연속성으로 캐시 효율 ↑ | 삽입/삭제 시 비효율적 (`O(n)`) |
| 동일 자료형 집합에 최적화     | 다른 자료형 저장 불가          |
| 구현이 단순하고 직관적        | 범위 초과 시 오류 가능성 존재  |
