# 0. 들어가기: Heap 이란?

> Heap은 "항상 가장 큰 값 또는 가장 작은 값을 빠르게 꺼낼 수 있도록 설계된 트리 기반의 자료구조"이다.
> 이를 사용하는 이유는 우선순위가 중요한 연산을 효율적으로 처리하기 위해서이다.

Heap은 영어로 "더미, 무더기"라는 뜻을 가지고 있다. 프로그래밍에서의 Heap은 **부모 노드가 자식 노드보다 크거나 작은 우선순위 조건을 만족하는 트리 기반 자료구조**이다. 특히, **항상 가장 큰 값(또는 가장 작은 값)을 빠르게 꺼낼 수 있도록 설계된 구조**라고 보면 된다.

# 1. Heap의 정의와 특징

> Heap은 **부모 노드가 자식 노드보다 크거나 (Max Heap), 작거나 (Min Heap) 해야 한다는 우선순위 조건을 만족하는 트리 기반의 자료구조**이다.
>
> 이러한 조건 덕분에 **최댓값 또는 최솟값을 빠르게 추출**할 수 있고, **삽입/삭제 연산도 효율적**이다.
>
> Heap은 다양한 형태로 구현될 수 있으며, 그 중 가장 일반적인 구현이 **Binary Heap**이다.
>
> Binary Heap은 **완전 이진 트리**(Complete Binary Tree)를 기반으로 하며, **배열로 효율적으로 구현**할 수 있다.

- 개념: 우선순위 조건을 만족하는 트리 자료구조로, Max Heap과 Min Heap으로 나뉜다.
- 특징: 최대값/최소값 추출은 O(1), 삽입/삭제는 O(log N)의 시간복잡도를 갖는다.
- 구현: Binary Heap은 완전 이진 트리를 기반으로 하며, 배열로 쉽게 구현할 수 있다.

# 2. Heap의 삽입/삭제 동작 원리

> Heap의 삽입과 삭제는 "heapify 과정을 통해 트리의 조건을 유지하는 연산"이다.
> 이를 사용하는 이유는 삽입/삭제 시에도 우선순위 조건(Max/Min)을 유지하기 위함이다.
> 이를 통해 Heap의 핵심 동작 방식과 시간 복잡도를 이해할 수 있다.

- 개념: 삽입 시 위로 올라가며 정렬, 삭제 시 아래로 내려가며 정렬하는 방식이다.
- 원리: Heapify-Up과 Heapify-Down을 통해 조건을 유지한다.

## 삽입 (Heapify-Up)

1. 배열의 **끝에 새 노드를 삽입**한다.
2. 부모와 비교하여 Heap 조건(Max/Min)을 만족하지 않으면 **swap하며 위로 올라간다.**

### Heap 삽입 연산의 구현 예시 (Max Heap 기준)

```python
# Python
def insert(heap, value):
	heap.append(value)
	i = len(heap) - 1

	while i > 0:
		parent = (i - 1) // 2
		if heap[i] > heap[parent]: # Max Heap 기준
			heap[i], heap[parent] = heap[parent], heap[i]
			i = parent
		else:
			break

```

## 삭제 (Heapify-Down)

1. **루트 노드를 삭제**하고, **마지막 노드를 루트에 위치시킨다.**
2. 자식 노드들과 비교하여 조건을 만족하지 않으면 **더 큰/작은 자식과 swap하며 아래로 내려간다.**

### Heap 삭제 연산의 구현 예시 (Max Heap 기준)

```python
# Python
def pop(heap):
	if not heap:
		return None

	top = heap[0]
	heap[0] = heap.pop()
	i = 0

	while (2 * i) + 1 < len(heap):
		left = (2 * i) + 1
		right = (2 * i) + 2
		max_child = left

		if right < len(heap) and heap[right] > heap[left]:
			max_child = right

		if heap[i] < heap[max_child]:
			heap[i], heap[max_child] = heap[max_child], heap[i]
			i = max_child
		else:
			break

	return top

```

※ 비교 기준만 Max Heap / Min Heap에서 달라지고, 로직은 동일하다.

# 3. Heap의 사용 예시

> Heap은 다양한 알고리즘에서 우선순위를 다루기 위한 도구로 사용된다.

## 우선순위 큐

- 여러 작업 중에서 **우선순위가 가장 높은 작업을 빠르게 꺼내야 할 때 사용**한다.

## 다익스트라 알고리즘

- 그래프에서 최소 비용 경로를 구할 때, **가장 가까운 정점을 효율적으로 선택**하기 위해 Heap을 사용한다.

## Heap Sort

- Heap을 이용해 정렬하는 알고리즘이다.

※ 자세한 내용은 이후 파트에서 다룰 예정이다.

# 4. 연습 문제

> Heap의 동작 원리를 연습해보는 문제이다.

- 문제: 다음 숫자를 Max Heap에 순서대로 삽입하고, 한 번 pop한 결과를 배열로 작성해 주세요. [10 → 40 → 30 → 60 → 90]
- 삽입 순서 과정
  1. 10 → [10]
  2. 40 → [40, 10] (40과 swap)
  3. 30 → [40, 10, 30]
  4. 60 → [60, 40, 30, 10] (60과 40 swap → 60과 10 swap)
  5. 90 → [90, 60, 30, 10, 40] (90과 60 swap → 90과 40과 swap)
- Pop 한 번 수행
  1. 90 제거 → [40, 60, 30, 10]
  2. 40과 60 비교 → swap → [60, 40, 30, 10]
- 최종 결과 배열: [60, 40, 30, 10]

# 마무리 요약

> Heap은 우선순위가 있는 데이터를 빠르게 다루는 데 최적화된 자료구조이다.

- Heap은 **완전 이진 트리를 기반으로 하는 트리형 자료구조**이다.
- **Max Heap / Min Heap**에 따라 부모-자식 관계 정렬 기준이 달라진다.
- **배열 기반으로 구현**되며, 삽입/삭제는 $O\,(log\,N)$, 최대값/최소값 추출은 $O\,(1)$이다.
- 우선순위 큐, 최단 경로 알고리즘, 정렬 등 실무 활용도가 매우 높다.