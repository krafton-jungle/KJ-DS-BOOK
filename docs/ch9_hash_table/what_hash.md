# Hash 함수

## 담당자: 김보아


# 자료구조

## **해시(Hash)란 무엇인가?**

해시(Hash) 단어는 맥락에 따라 서로 다른 의미로 쓰인다. 가장 대표적인 두 가지는 다음과 같다.

1. **해시 값(Hash Value)**
    
    해시는 어떤 데이터를 고정된 크기의 숫자 등으로 변환한 결과값을 뜻한다. 예를 들어, 문자열 "Jungle"을 숫자 9로 변환하는 해시 함수가 있다면, 이 9는 단순한 숫자가 아니라, "Jungle" 데이터를 배열이나 테이블에서 저장하거나 찾을 위치(index)로 사용된다. 이 숫자 9가 바로 해시 값이다.
    
2. **해시 기법 또는 해싱 (Hashing)**
    
    해싱은 임의의 크기를 가진 데이터를 고정된 크기의 해시 값으로 변환하는 과정을 의미하며, 이를 통해 데이터를 효율적으로 저장하고 검색할 수 있도록 하는 기법이다. 일반적으로 키(key)를 해시 함수에 입력하여 해시 값을 생성하고, 이 해시 값을 데이터 저장소(예: 해시 테이블)의 인덱스로 사용한다.
    
    즉, 해싱은 해시 함수를 활용해 데이터 위치를 계산하는 과정이며, 해시 테이블이나 해시 맵과 같은 자료구조는 이 해싱 기법을 적용하여 구현된 대표적인 예시이다. 
    

## 왜 해싱이 필요한가?

정렬되지 않은 배열에서 특정 데이터를 찾으려면 컴퓨터가 처음부터 끝까지 차례대로 검색해야 하므로, 검색 연산에 $O(N)$의 시간이 소요된다. 배열이 정렬되어 있으면 이진 검색(Binary Search)을 사용할 수 있어 검색 시간이 $O(log N)$으로 줄어들지만, 삽입과 삭제 연산 시에는 여전히 배열 요소를 이동해야 하는 부담이 있다.

반면, 해싱은 키를 해시 함수에 입력해 데이터가 저장될 위치를 즉시 계산하므로, 평균적으로 검색, 삽입, 삭제 연산을 모두 $O(1)$ 시간 내에 처리할 수 있다. 다만, 해시 충돌이 발생할 경우 최악의 경우 시간 복잡도가 $O(N)$까지 늘어날 수 있으나, 적절한 해시 함수와 충돌 해결 기법을 사용하면 이러한 상황을 최소화할 수 있다.

이처럼 해싱은 데이터 검색뿐 아니라 삽입과 삭제도 매우 효율적으로 처리할 수 있기 때문에, 다양한 응용 분야에서 널리 사용된다.

## 해싱의 구성 요소

| 용어 | 설명 |
| --- | --- |
| **1. 키 (Key)** | 입력 데이터. 예: `"jungle"`, `0904`, `"user_id"` |
| **2. 해시 함수** | 해시 테이블에서 데이터를 저장할 위치(인덱스)를 결정하는 계산 방법 |
| **3. 해시 값 (Hash Value)** | 해시 함수의 출력값으로, 일반적으로 테이블의 인덱스로 사용 |
| **4. 해시 테이블 (Hash Table)** | 해시 값에 따라 데이터를 저장하는 실제 저장 공간 (보통 배열 기반의 구조) |
| **5. 충돌 처리 방식** | 서로 다른 키가 같은 해시 값을 가질 경우(충돌), 데이터를 저장하는 전략 (예: 체이닝, 오픈 주소법) |

4번, 5번은 뒤에서 더 자세하게 다룬다.

## 해시 함수(Hash Function)란 무엇인가?

해시 함수는 컴퓨터 과학에서 핵심적으로 활용되는 개념으로, 입력 데이터를 고정된 크기의 해시 값(hash value) 또는 다이제스트(digest)로 변환한다. 이러한 특성 덕분에 해시 함수는 데이터 저장, 검색, 보안 등 다양한 분야에서 널리 사용된다.

### **해시 함수의 특성**

| 특성 | 설명 |
| --- | --- |
| **결정론적(Deterministic)** | 동일한 입력은 항상 동일한 출력 값을 가진다 |
| **고정된 출력 크기** | 입력 크기와 무관하게, 출력은 일정한 길이를 유지한다. |
| **효율성(Efficiency)** | 계산이 빠르고, 자원 소모가 적어야 한다. |
| **균등 분포(Uniformity)** | 출력 값이 가능한 고르게 분포되어야 충돌(collision)을 최소화 한다. |
| **역상 저항성(Pre-image Resistance)** | 해시 값을 보고 원래 입력 값을 유추하는 것이 매우 어려워야 한다. |
| **충돌 저항성(Collision Resistance)** | 서로 다른 두 입력이 같은 해시 값을 갖기 어렵도록 설계되어야 한다. |
| **눈사태 효과(Avalanche Effect)** | 입력이 아주 조금만 바뀌어도 출력은 완전히 달라져야 한다. |

## 해시 함수의 종류

### 1. 나눗셈 방법 (Division Method)

**정의**

> $h(k) = k \,mod\,m$
> 
> 
> 키 `k`를 어떤 수 `m`으로 나눈 나머지를 해시값으로 사용한다.
> 

**장점**

- 가장 간단하고 빠르게 구현이 가능하다.
- 대부분의 경우 충분히 효과적이다.

**단점**

- `m`의 선택이 성능에 영향을 미친다.
- 특히 `m`이 2의 거듭제곱이면 충돌이 자주 발생한다.

**보통 어디에 쓰이는가?**

- 일반적인 해시 테이블 구현에 많이 사용된다.
- 예: `Python dict`, `C++ unordered_map`의 기본 구조 중 일부이다.
- 소형 키에 대해 빠르게 해시 계산이 필요할 때 적합하다.

---

### 2. 곱셈 방법 (Multiplication Method)

**정의**

> $h(k) = ⌊ m(kA \,mod\, 1) ⌋$
> 
> 
> 실수 A(0 < A < 1)와의 곱을 이용해 소수점 이하 부분을 취한다.
> 

**장점**

- `m`의 선택에 민감하지 않다.
- 분포가 비교적 균등하게 나온다.

**단점**

- 실수 계산이 필요해 구현이 다소 복잡하다.
- 성능 튜닝이 어려울 수 있다.

**보통 어디에 쓰이는가?**

- 시스템 수준 해시 테이블, 예: 자바의 `HashMap` 내부 구조.
- 고속 해시 분산이 필요한 경우에 사용한다.

---

### 3. 중앙 제곱법 (Mid-Square Method)

**정의**

> 키를 제곱한 뒤, 중앙 부분의 몇 자릿수를 추출해 해시값으로 사용한다.
> 

**장점**

- 키 값이 유사해도 비교적 다양한 해시값을 생성한다.
- 균등 분포 가능성 있다.

**단점**

- 제곱 계산이 필요해 연산량이 많다.
- 키의 길이에 따라 조정이 필요하다.

**보통 어디에 쓰이는가?**

- 학습용 또는 소형 해시 테이블로 쓰인다.
- 실사용보다는 개념 이해와 시뮬레이션에서 많이 등장한다.

---

### 4. 폴딩 방법 (Folding Method)

**정의**

> 키를 여러 부분으로 나눈 뒤, 각 부분을 더하거나 XOR한 값을 사용한다.
> 

**장점**

- 단순하고 빠르다.
- 키가 긴 경우에도 적절히 분할 가능하다.

**단점**

- 분할 방식에 따라 성능이 달라진다.
- 일부 자릿수에 치우친 해시가 생길 수 있다.

**보통 어디에 쓰이는가?**

- 문자열이나 긴 숫자 해싱
- 메모리 주소 해시나 특정 구조체 키에 적합

---

### 5. 암호학적 해시 함수 (Cryptographic Hash Functions)

**예**: `MD5`, `SHA-1`, `SHA-256`, `BLAKE2`, `SHA-3`

**특징**

- 해시값만 보고 원래 데이터를 유추할 수 없다.
- 충돌 가능성이 극도로 낮다.
- 작은 변화도 완전히 다른 해시값을 생성한다.

**장점**

- 보안성이 매우 높다.
- 서명, 무결성 검증, 패스워드 저장에 최적

**단점**

- 일반 해시 함수보다 계산량이 많고 느리다.

**보통 어디에 쓰이는가?**

- 비밀번호 저장 
- 디지털 서명, 메시지 무결성 확인
- 블록체인, 인증 시스템

---

### 6. 유니버설 해싱 (Universal Hashing)

**정의**

> $h(k) = ((a * k + b) \,mod \,p) \,mod \,m$
> 
> 
> `a`, `b`는 무작위 값, `p`는 큰 소수
> 

**장점**

- 최악의 경우에도 충돌 확률이 낮다.
- 적절한 수학적 기반이다.

**단점**

- 무작위 상수 `a`, `b` 보관 필요
- 구현 복잡도와 계산량 약간 증가

**보통 어디에 쓰이는가?**

- 보안 해시, 네트워크 해시, 데이터 스트럭처 강의 예제
- 경쟁적 환경에서 해시 충돌 공격을 방지하려는 경우

---

### 7. 완전 해싱 (Perfect Hashing)

**정의**

- 충돌이 절대 발생하지 않는 해시 함수
- 최소 완전 해싱: N개의 키를 정확히 N칸에 배치
- 비최소 완전 해싱: 일부 공간 낭비 허용

**장점**

- 탐색 시간이 $O(1)$, 충돌이 없다.
- 읽기 전용 데이터 구조에 매우 효율적이다.

**단점**

- 생성 비용이 크고, 데이터 변경이 어렵다.
- 동적 데이터셋에는 부적합하다.

**보통 어디에 쓰이는가?**

- 컴파일러 키워드 테이블, 상수 기반 테이블로 쓰인다.
- 고정된 룩업 테이블에서 매우 유용하다.

## 좋은 해시 함수란 무엇인가

### 좋은 해시 함수의 조건

- **균등한 분포**
    
    해시 함수는 서로 다른 입력 키들을 가능한 한 해시 테이블 전반에 고르게 분포시켜야 한다. 분포가 한쪽에 치우치면 충돌이 자주 발생하고 성능이 저하된다.
    
- **결정성**
    
    같은 입력값에 대해서는 항상 같은 출력값(해시 값)을 반환해야 한다. 그래야 같은 데이터를 항상 같은 위치에 저장하거나 검색할 수 있다.
    
- **빠른 계산 속도**
    
    해시 함수는 데이터 삽입과 검색에서 매우 자주 호출되므로 계산이 빨라야 전체 성능이 떨어지지 않는다.
    
- **충돌 최소화**
    
    서로 다른 키들이 같은 해시 값을 가질 가능성을 최대한 줄여야 한다. 충돌이 잦아지면 별도의 충돌 처리 비용이 발생하고 성능이 떨어진다.
    

## 해시 함수 설계 시 고려사항

- **입력 키의 특성**
    
    문자열, 정수, 날짜 등 키의 타입과 구조에 따라 적절한 해시 함수 방식이 달라질 수 있다. 예를 들어, 문자열은 아스키 값을 조합하는 방식이나 비트 연산 기반 해시가 자주 쓰인다.
    
- **사용 목적**
    
    보안이 중요한 경우는 암호학적 해시 함수를 사용하고, 일반적인 자료 검색용 해시 테이블에서는 빠르고 간단한 해시 함수가 적절하다.
    
- **충돌 허용 수준**
    
    약간의 충돌을 허용할 수 있는지, 아니면 완전 해싱(perfect hashing)이 필요한지에 따라 방식이 달라진다.
    
- **테이블 크기(m)의 선택**
    
    나눗셈 방법에서는 m을 소수로 선택하는 것이 중요하다. m이 키 값의 패턴과 맞물리면 충돌이 심해질 수 있다.
    

## 해싱이 적합하지 않은 경우

해싱이 빠르고 유용한 방법이긴 하지만, 항상 최선의 선택은 아니다. 다음과 같은 경우에는 해시 테이블 대신 다른 자료구조를 고려해야 한다.

- **정렬된 데이터를 유지해야 할 경우**
    
    자기 균형 이진 탐색 트리(Self-balancing BST)를 사용한다. (예: AVL Tree, Red-Black Tree)
    
- **문자열을 키로 사용하고 접두사 검색(prefix search)이 필요한 경우**
    
    트라이(Trie)가 적합하다. 트라이는 공통 접두사를 공유하며 저장하기 때문에 검색 성능이 좋다.
    
- **floor(이전 가장 가까운 값), ceiling(다음 가장 가까운 값) 같은 연산이 필요한 경우**
    
    이런 연산은 해시 테이블에서는 불가능하며, Self-balancing BST가 알맞다.

## 이번 장을 마무리하며
이번 장에서는 다양한 해시 함수들과 그 특성을 살펴보았습니다.
실제로 시스템을 설계하거나 코드를 구현할 때는, 이론적 성능만큼이나 충돌 처리 방식, 입력 키의 특성, 그리고 언어/프레임워크에서 기본으로 제공되는 해시 구현 등을 함께 고려해야 합니다.

예를 들어 Python의 dict나 Java의 HashMap, C++의 unordered_map은 내부적으로 자체 최적화된 해시 함수를 사용하므로, 대부분의 일반적인 사용 사례에서는 별도로 해시 함수를 구현할 필요가 없습니다. 그러나 대용량 데이터를 다루거나, 키가 매우 불균형한 경우, 혹은 해시 충돌이 보안 이슈가 될 수 있는 환경에서는 커스텀 해시 함수 또는 충돌 방지 설계가 필요할 수 있습니다.

다음 장에서는 해시 함수가 실제로 사용되는 해시 테이블 구조와, 실무에서 자주 문제로 등장하는 충돌 상황을 어떻게 처리하는지에 대해 구체적으로 다뤄보겠습니다.