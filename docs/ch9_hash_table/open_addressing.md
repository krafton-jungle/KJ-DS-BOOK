# Open Addressing

## Open Addressing의 개념
Open Addressing(개방 주소법)은 충돌이 발생했을 때 해시 테이블 내의 다른 빈 버킷을 찾아 데이터를 저장하는 방법이다.  
체이닝과 달리 모든 요소가 해시 테이블 자체에 저장되므로, 별도의 연결 리스트나 포인터가 필요하지 않다.  
Open Addressing에서는 충돌이 발생하면 탐사(Probing)라는 과정을 통해 비어있는 버킷을 찾는다.  
이때 각 요소마다 선호하는 위치 순서가 다를 수 있으며, 빈 버킷을 찾을 때까지 계속해서 다음 선택 위치를 확인한다.

## Open Addressing의 특징
- 모든 요소가 해시 테이블 내에 직접 저장된다.
- 부하율 제한: 해시 테이블의 부하율(load factor)은 1을 초과할 수 없다.
- 성능은 부하율에 크게 의존한다. 일반적으로 부하율이 0.7을 넘으면 급격하게 성능이 저하된다.
- 포인터나 추가 자료구조가 불필요하여 메모리 사용량이 적다.
- 연속된 메모리 공간을 사용하여 캐시 성능이 우수하다.

## Linear Probing(선형 탐사법)

선형 탐사법은 충돌이 발생했을 때 한 칸씩 순차적으로 이동하며 빈 버킷을 찾는 간단한 방법이다.

$$ h(k, i) = (h(k) + i) mod\, m $$  
m은 해시 테이블 크기, i는 충돌 횟수를 의미한다.

| **장점** | **단점** |
| --- | --- |
| 구현이 간단하고 직관적이다. | 연속된 데이터가 한 곳에 몰리는 1차 군집화 문제 발생|
| | 한 번 충돌이 나면 집중적으로 충돌이 발생하여 평균 시간 증가|
| | 최악의 경우 버킷 전체를 선형적으로 탐색|



### **동작 방식**
![선형 탐사](/assets/ch9_hash_table/open_address_1.png)

충돌이 발생하면 빈 버킷을 한 칸씩 탐색하며 빈 버킷에 삽입한다.

## Quadratic Probing(이차 탐사법)

이차 탐사법은 충돌시 이동 거리를 제곱수 만큼 떨어진 위치를 탐사하는 방법이다.

선형 탐사법의 군집화 문제를 해결하기 위해 고안되었다.

$$ h(k, i) = (h(k) + i^2) mod\, m $$

| **장점** | **단점** |
| --- | --- |
| 선형 탐사에서 발생하는 클러스터링(군집화) 문제를 완화 | 배열 크기가 소수(prime)가 아니면 특정 키를 저장하지 못할 수 있다.|
| | 2차 군집화 문제가 발생|


### **동작 방식**

![이차 탐사](/assets/ch9_hash_table/open_address_2.png)

해시 충돌이 발생하면 한 칸씩이 아닌 i²으로 지수적으로 탐색하여 빈 버킷에 삽입한다.

## Double Hashing(이중 해싱법)

이중 해싱법은 충돌 시 원래 해시함수 h(k)와 다른 별개의 해시함수 h’(k)를 추가로 사용하는 방법이다.

$$ h(k, i) = (h1(k) + i \times h2(k)) mod\, m $$

| **장점** | **단점** |
| --- | --- |
| 군집화 문제를 가장 효과적으로 해결한다. | 두 해시 함수의 계산 비용이 증가할 수 있다.|



### **동작 방식**

![이차 탐사](/assets/ch9_hash_table/open_address_3.png)

해시 충돌이 발생하면 이차 해시 함수를 통과하여 삽입할 위치를 결정한다.

주의: 이중 해싱이 올바르게 동작하려면 두 번째 해시 함수는 0을 반환하면 안된다.  
0을 반환한다면 계속 같은 자리만 확인하게 되어 무한루프에 빠지게 된다.

### 정리

|  | **선형 탐사법** | **이차 탐사법** | **이중 해싱법** |
| --- | --- | --- | --- |
| 탐색 방식 | 순차적으로 다음 공간 탐색 | 제곱수만큼 떨어진 공간 탐색 | 두 번째 해시함수를 이용해 탐색 |
| 장점 | 구현이 간단하고 직관적 | 1차 군집화 문제 완화 | 군집화 문제를 가장 효과적으로 해결 |
| 단점 | 1차 군집화 문제 발생 | 2차 군집화 문제 발생, 테이블 크기가 소수가 아니면 저장 불가능 | 두 해시 함수로 인한 계산 비용 증가 |
| 구현 복잡도 | 낮음 | 중간 | 높음 |
| 해시 함수 | $$ h(k,i) = (h(k) + i) mod\, m $$ | $$ h(k,i) = (h(k) + i^2) mod\, m $$ | $$ h(k,i) = (h1(k) + i \times h2(k)) mod\, m $$ |
