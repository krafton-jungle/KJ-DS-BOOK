# Hash Table(map)
## 해시맵(Hash Map) 과 해시테이블(Hash Table) 차이

 해시테이블과 해시맵은 모두 데이터를 키와 값의 쌍으로 저장하고 빠르게 조회할 수 있는 자료구조 또는 인터페이스이다. 이 둘은 종종 같은 의미로 혼용되지만 실제로는 약간의 관점 차이가 존재한다. 이 차이는 주로 "구현"과 "사용"의 관점에서 이해할 수 있다.

### 해시테이블

- 해시테이블은 **자료구조 자체**를 의미한다.
- 기본적으로 배열 기반의 저장공간, 해시 함수, 충돌 처리 방식으로 구성된다.
- 자료구조 수업이나 알고리즘 인터뷰 등에서 내부 구조 설계나 구현을 다룰 때 주로 사용되는 용어이다.
- 해시 함수 설계, 충돌 가능성, 적재율 계산 등 **저수준의 동작 원리**를 이해할 때 중점적으로 다룬다.

### 해시맵

- 해시맵은 **프로그래밍 언어에서 제공하는 맵 자료형 또는 라이브러리 이름**이다.
- 자바의 `HashMap`, C++의 `unordered_map`, 파이썬의 `dict` 등은 모두 해시 테이블 기반의 구현체이다.
- 사용자는 키-값 쌍을 저장/조회할 수 있으며, 내부 구현을 몰라도 고수준 인터페이스로 편리하게 사용할 수 있다.

| 항목 | 해시 테이블 (Hash Table) | 해시 맵 (Hash Map) |
| --- | --- | --- |
| 관점 | 구현 중심 | 사용 중심 |
| 의미 | 자료구조 개념 자체 | 해시 테이블 기반 Map API |
| 주요 구성 | 배열, 해시 함수, 충돌 처리 등 | 내부적으로 해시 테이블 사용 |
| 사용 목적 | 자료구조 설계, 이론 이해 | 실제 프로그램에서 데이터 저장 |
| 등장 위치 | 알고리즘 수업, 시스템 내부 | 고급 언어의 표준 라이브러리 |
| 예시 | 체이닝, 개방 주소법 구현 | `HashMap`, `unordered` |

## 해시테이블이란?

해시테이블(Hash Table)은 키(key)를 값(value)에 매핑하는 자료구조로, 흔히 **딕셔너리(Dictionary)** 혹은 **맵(Map)** 이라고도 불린다. 다음과 같은 연산들을 빠르게 수행할 수 있어 다양한 응용에서 핵심적인 역할을 한다:

- **삽입 (Insert)**
- **탐색 (Search)**
- **삭제 (Delete)**

예: 컴파일러의 심볼 테이블(Symbol Table)에서는 식별자(변수명, 함수명 등)를 키로 사용하고, 관련 정보를 값으로 저장한다.

### 해시테이블의 작동 방식

1. 해시 함수(Hash Function)로 키를 정수값으로 변환한다.
2. 이 정수를 배열 인덱스로 사용한다. 이 인덱스를 **버킷(Bucket)** 또는 <b>슬롯(Slot)</b>이라고 부른다.
3. 검색 시에도 같은 해시 함수를 통해 인덱스를 계산하여 값에 접근한다.

따라서 탐색 시에도 동일한 해시 함수를 이용해 키를 인덱스로 변환하고, 해당 위치에서 원하는 값을 직접 조회하게 된다. 이러한 구조의 <b>맵(Map)을 해시맵(HashMap)</b>이라고 부르기도 한다.


### 시간 복잡도 및 효율성

적절히 설계된 해시테이블은 저장된 요소의 개수에 크게 영향을 받지 않고, 대부분의 연산을 **평균적으로 $O_{(1)}$의 시간** 안에 수행할 수 있다.

> 예외적으로, 충돌이 과도하거나 해시 함수가 불균형하면  최악의 경우 <b>$O_{(n)}$</b>의 시간이 소요될 수 있다.
> 

| **비교 항목** | **해시 테이블** | **이진 탐색 트리** (BST) | **배열 (정렬/비정렬)** | **연결 리스트** |
| --- | --- | --- | --- | --- |
| **검색 시간** | 평균 Θ(1), 최악 O(n) | 평균 O(log n), 최악 O(n) | 정렬: O(log n) / 비정렬: O(n) | O(n) |
| **삽입 시간** | 평균 Θ(1), 최악 O(n) | 평균 O(log n), 최악 O(n) | 정렬: O(n) / 비정렬: O(1) | O(1) (맨 앞 삽입 시) |
| **삭제 시간** | 평균 Θ(1), 최악 O(n) | 평균 O(log n), 최악 O(n) | 정렬: O(n) / 비정렬: O(n) | O(n) |
| **메모리 사용량** | O(n) + 오버헤드 (버킷 등) | O(n) + 노드 포인터 | O(n) | O(n) + 포인터 오버헤드 |
| **정렬된 순회 지원** |  지원하지 않음 | 중위 순회로 정렬 가능 | 정렬 배열만 가능 | 지원 어려움 |
| **충돌/균형 고려 요소** | 충돌 처리 필요 (체이닝, 개방 주소법 등) | 균형 유지 필요 (AVL, RB 등) | 정렬 여부에 따라 다름 | 없음 |
| **장점** | 매우 빠른 평균 속도, 단순 구조 | 정렬된 데이터 지원, 검색 속도 안정적 | 구조 단순, 메모리 사용 예측 가능 | 구현 간단 |
| **단점** | 충돌 발생 가능, 정렬 불가 | 구현 복잡, 회전 필요 | 느린 삽입/삭제 (정렬 시) | 느린 탐색, 정렬 어려움 |

<p align="center"><b>해시테이블 VS 다른 탐색 구조 비교표</b></p>

### 해싱은 자원 간 절충이다

해싱은 공간과 시간의 절충(trade-off)을 보여주는 전형적인 예이다.

- **메모리가 무한하다면** 모든 가능한 키 값을 배열의 인덱스로 직접 사용하여, 단 한 번의 메모리 접근으로 데이터를 찾을 수 있다.
- **시간이 무한하다면** 키와는 무관하게 데이터를 무작위로 저장한 뒤, 이진 탐색이나 선형 탐색으로 원하는 값을 찾을 수 있다.

하지만 현실 세계에서 자원은 유한하므로, 해시테이블은 **빠른 접근성과 적절한 메모리 사용량 사이의 균형**을 맞추는 훌륭한 해결책이다.

### 활용 분야

해시테이블은 **탐색 트리**나 **선형 테이블 기반 구조**보다 평균적으로 훨씬 더 효율적인 성능을 제공하므로, 다음과 같은 분야에서 널리 사용된다:

- 데이터베이스 인덱싱
- 캐시(Cache)
- 중복 제거(Set)
- 라우팅 테이블, 인터프리터 심볼 테이블 등

## 해시테이블의 원리

![해시테이블](/assets/ch9_hash_table/hash_function.png)

<p align="center"> <b> 그림 1. 해시 테이블 기본 구조</b></p>
 

## 해시테이블의 핵심 구성요소 설명 

  해시테이블은 데이터를 효율적으로 저장하고 관리하기 위해 여러 핵심구성요소가 함께 작동하는 구조이다.

### 1. 해시함수 

  해시테이블의 핵심요소로 입력 키를 받아 해당키가 저장될 배열의 인덱스(버킷 또는 슬롯)을 계산한다.
  해시함수의 성능은 데이터 분포에 직접적인 영향을 미치기 때문에 매우 중요하다
  좋은해시 함수는 충돌을 최소화하고 데이터를 테이블 전체에 균등하게 분산시켜준다.

### 2. 버킷 

   해시 테이블에서 데이터를 실제로 저장하는 위치이다. 가장 단순한 형태로는 각 버킷에 키-값 쌍으로

   저장되지만 충돌 처리 전략에 따라 하나의 버킷에 여러 항목이 저장 될 수 있다. 경우에 따라 연결리스트나

   복잡한 구조를 사용할 수 있다.

## 해시테이블 변형
전통적인 해시테이블은 평균적으로 $O_{(1)}$의 우수한 성능을 보이나, 최악의 경우 $O_{(n)}$의 시간 복잡도를 가진다는 한계가 있다. 이러한 문제를 해결하기 위해 다양한 고급 해시테이블 변형들이 연구되어 왔으며, 각각은 특정 상황에서 기존 방식보다 우수한 성능을 제공한다.

### 1. 뻐꾸기 해싱 (Cuckoo Hashing)
#### 기본 개념
뻐꾸기 해싱은 Pagh와 Rodler에 의해 2001년에 제안된 해싱 기법으로, 최악의 경우에도 상수 시간 검색을 보장한다는 특징을 가진다.
#### 동작 원리
이 방식은 두 개의 독립적인 해시 함수$h_1(x)$와 $h_2(x)$를 사용하여, 각 키가 정확히 두 개의 위치 중 하나에만 저장될 수 있도록 한다. 충돌이 발생할 경우, 기존에 저장된 항목을 다른 해시 함수로 계산된 위치로 이동시키는 방식을 채택한다. 이러한 동작 방식이 뻐꾸기가 다른 새의 둥지에서 알을 밀어내는 행동과 유사하여 'Cuckoo Hashing'이라는 명칭을 얻게 되었다.
#### 성능 특성

  - **검색 시간**: 최악의 경우에도 $O_{(1)}$ 시간 복잡도를 보장한다<br>
  - **메모리 접근**: 검색 시 최대 2번의 메모리 접근만 필요하다
  - **적재율**: 일반적으로 50% 이하에서 안정적인 성능을 보인다

#### 한계점
삽입 과정이 복잡하며, 높은 적재율에서는 무한 루프나 재해싱이 필요할 수 있다는 단점을 가진다.

### 2. 로빈후드해싱(Robin Hood Hashing)
#### 기본 개념
로빈후드해싱은 개방 주소법 기반의 해싱 기법으로, Pedro Celis에 의해 1986년에 처음 제안되었다.  
이 방법은 "부자에게서 가져와 가난한 자에게 준다"는 Robin Hood의 철학을 해싱에 적용한 것이다.
#### 동작 원리
이 기법에서는 각 항목의 PSL(Probe Sequence Length)을 추적한다. PSL은 해당 항목이 원래 해시된 위치에서 실제로 저장된 위치까지의 거리를 의미한다.  
새로운 키를 삽입할 때, 현재 위치에 있는 항목보다 더 긴 PSL을 가진 경우 해당 항목을 밀어내고 자신의 자리를 차지하게 된다.
#### 성능 특성
  - **평균 성능**: 기존 해시테이블 대비 우수한 평균 검색 시간을 보인다  
  - **메모리 지역성**: 연속적인 메모리 접근으로 캐시 친화적인 특성을 가진다<br>
  - **분산**: 항목들의 PSL 분산을 최소화하여 전체적으로 균등한 성능을 제공한다

### 3. 홉스카치 해싱(Hopscotch Hashing)
#### 기본 개념
홉스카치 해싱은 Herlihy, Shavit, Tzafrir에 의해 2008년에 제안된 기법으로, 동시성 환경에서의 해시테이블 성능 향상을 목적으로 한다.
#### 동작 원리
각 버킷은 <b>H 크기의 이웃 범위(neighborhood)</b>를 가지며, 해당 버킷에 해시된 항목들은 이 범위 내에서만 저장된다.  
이러한 구조는 **데이터가 해시된 위치 근처에 유지되도록 보장하며**, 병렬 처리 환경에서 **동기화 오버헤드를 최소화**하는 데 기여한다.

#### 특징
- **동시성**: 멀티스레드 환경에서 우수한 성능을 보인다
- **지역성**: 제한된 범위 내에서의 항목 이동으로 예측 가능한 성능을 제공한다

### 4. 일관성 해싱 (Consistent Hashing)
####  기본 개념
일관성 해싱은 Karger 등에 의해 1997년에 제안된 기법으로, 분산 시스템에서 데이터 분배와 로드 밸런싱을 위해 설계되었다.
#### 동작 원리
해시 함수의 출력 공간을 원형 링으로 구성하여, 서버의 추가나 제거 시에도 최소한의 키 재배치만이 발생하도록 한다. 각 서버와 키는 링 위의 특정 지점에 배치되며, 키는 시계 방향으로 가장 가까운 서버에 할당된다.
#### 응용 분야
  - **분산 캐시 시스템**: Memcached, Redis Cluster 등<br>
  - **CDN**: 콘텐츠 배포 네트워크에서의 서버 선택<br>
  - **로드 밸런싱**: 동적 서버 환경에서의 부하 분산

## 담당자: 류승찬