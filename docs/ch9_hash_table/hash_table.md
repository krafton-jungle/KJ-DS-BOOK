# Hash Table(map)
## 해시맵(Hash Map) 과 해시테이블(Hash Table) 차이

 해시테이블과 해시맵은 모두 데이터를 키와 값의 쌍으로 저장하고 빠르게 조회할 수 있는 자료구조 또는 인터페이스이다. 이 둘은 종종 같은 의미로 혼용되지만 실제로는 약간의 관점 차이가 존재한다. 이 차이는 주로 "구현"과 "사용"의 관점에서 이해할 수 있다.

### 해시테이블

- 해시테이블은 **자료구조 자체**를 의미한다.
- 기본적으로 배열 기반의 저장공간, 해시 함수, 충돌 처리 방식으로 구성된다.
- 자료구조 수업이나 알고리즘 인터뷰 등에서 내부 구조 설계나 구현을 다룰 때 주로 사용되는 용어이다.
- 해시 함수 설계, 충돌 가능성, 적재율 계산 등 **저수준의 동작 원리**를 이해할 때 중점적으로 다룬다.

### 해시맵

- 해시맵은 **프로그래밍 언어에서 제공하는 맵 자료형 또는 라이브러리 이름**이다.
- 자바의 `HashMap`, C++의 `unordered_map`, 파이썬의 `dict` 등은 모두 해시 테이블 기반의 구현체이다.
- 사용자는 키-값 쌍을 저장/조회할 수 있으며, 내부 구현을 몰라도 고수준 인터페이스로 편리하게 사용할 수 있다.
- 실무 개발에서는 해시맵이 주로 사용된다.

| 항목 | 해시 테이블 (Hash Table) | 해시 맵 (Hash Map) |
| --- | --- | --- |
| 관점 | 구현 중심 | 사용 중심 |
| 의미 | 자료구조 개념 자체 | 해시 테이블 기반 Map API |
| 주요 구성 | 배열, 해시 함수, 충돌 처리 등 | 내부적으로 해시 테이블 사용 |
| 사용 목적 | 자료구조 설계, 이론 이해 | 실제 프로그램에서 데이터 저장 |
| 등장 위치 | 알고리즘 수업, 시스템 내부 | 고급 언어의 표준 라이브러리 |
| 예시 | 체이닝, 개방 주소법 구현 | `HashMap`, `unordered` |

## 해시테이블이란?

해시테이블(Hash Table)은 키(key)를 값(value)에 매핑하는 자료구조로, 흔히 **딕셔너리(Dictionary)** 혹은 **맵(Map)**이라고도 불린다. 다음과 같은 연산들을 빠르게 수행할 수 있어 다양한 응용에서 핵심적인 역할을 한다:

- **삽입 (Insert)**
- **탐색 (Search)**
- **삭제 (Delete)**

예: 컴파일러의 심볼 테이블(Symbol Table)에서는 식별자(변수명, 함수명 등)를 키로 사용하고, 관련 정보를 값으로 저장한다.

### 해시테이블의 작동 방식

1. 해시 함수(Hash Function)로 키를 정수값으로 변환한다.
2. 이 정수를 배열 인덱스로 사용한다. 이 인덱스를 **버킷(Bucket)** 또는 **슬롯(Slot)**이라고 부른다.
3. 검색 시에도 같은 해시 함수를 통해 인덱스를 계산하여 값에 접근한다.

따라서 탐색 시에도 동일한 해시 함수를 이용해 키를 인덱스로 변환하고, 해당 위치에서 원하는 값을 직접 조회하게 된다. 이러한 구조의 맵(Map)을 해시맵(HashMap)**이라고 부르기도 한다.

### 충돌과 그 처리

현실적으로는 서로 다른 키가 동일한 인덱스를 가질 수 있으며, 이를 **해시 충돌(Hash Collision)**이라 한다.

충돌 처리 전략에는 다음이 있다:

- **체이닝(Chaining)**: 같은 인덱스에 여러 데이터를 리스트 등으로 연결
- **개방 주소법(Open Addressing)**: 빈 슬롯을 찾아 저장 (선형 탐사, 이차 탐사, 이중 해싱 등)

| 연산 | 평균 시간 복잡도 | 최악의 시간 복잡도 |
| --- | --- | --- |
| 검색 | Θ(1) | O(n) |
| 삽입 | Θ(1) | O(n) |
| 삭제 | Θ(1) | O(n) |

참조) 시간복잡도

### 시간 복잡도 및 효율성

적절히 설계된 해시테이블은 저장된 요소의 개수에 크게 영향을 받지 않고, 대부분의 연산을 **평균적으로 $O(1)$의 시간** 안에 수행할 수 있다.

> 예외적으로, 충돌이 과도하거나 해시 함수가 불균형하면  최악의 경우 **$O(n)$**의 시간이 소요될 수 있다.
> 

| **비교 항목** | **해시 테이블** | **이진 탐색 트리** (BST) | **배열 (정렬/비정렬)** | **연결 리스트** |
| --- | --- | --- | --- | --- |
| **검색 시간** | 평균 Θ(1), 최악 O(n) | 평균 O(log n), 최악 O(n) | 정렬: O(log n) / 비정렬: O(n) | O(n) |
| **삽입 시간** | 평균 Θ(1), 최악 O(n) | 평균 O(log n), 최악 O(n) | 정렬: O(n) / 비정렬: O(1) | O(1) (맨 앞 삽입 시) |
| **삭제 시간** | 평균 Θ(1), 최악 O(n) | 평균 O(log n), 최악 O(n) | 정렬: O(n) / 비정렬: O(n) | O(n) |
| **메모리 사용량** | O(n) + 오버헤드 (버킷 등) | O(n) + 노드 포인터 | O(n) | O(n) + 포인터 오버헤드 |
| **정렬된 순회 지원** |  지원하지 않음 | 중위 순회로 정렬 가능 | 정렬 배열만 가능 | 지원 어려움 |
| **충돌/균형 고려 요소** | 충돌 처리 필요 (체이닝, 개방 주소법 등) | 균형 유지 필요 (AVL, RB 등) | 정렬 여부에 따라 다름 | 없음 |
| **장점** | 매우 빠른 평균 속도, 단순 구조 | 정렬된 데이터 지원, 검색 속도 안정적 | 구조 단순, 메모리 사용 예측 가능 | 구현 간단 |
| **단점** | 충돌 발생 가능, 정렬 불가 | 구현 복잡, 회전 필요 | 느린 삽입/삭제 (정렬 시) | 느린 탐색, 정렬 어려움 |

                                                        참조) 해시테이블 VS 다른 탐색 구조 비교표

### 해싱은 자원 간 절충이다

해싱은 공간과 시간의 절충(trade-off)을 보여주는 전형적인 예이다.

- **메모리가 무한하다면** 모든 가능한 키 값을 배열의 인덱스로 직접 사용하여, 단 한 번의 메모리 접근으로 데이터를 찾을 수 있다.
- **시간이 무한하다면** 키와는 무관하게 데이터를 무작위로 저장한 뒤, 이진 탐색이나 선형 탐색으로 원하는 값을 찾을 수 있다.

하지만 현실 세계에서 자원은 유한하므로, 해시테이블은 **빠른 접근성과 적절한 메모리 사용량 사이의 균형**을 맞추는 훌륭한 해결책이다.

### 활용 분야

해시테이블은 **탐색 트리**나 **선형 테이블 기반 구조**보다 평균적으로 훨씬 더 효율적인 성능을 제공하므로, 다음과 같은 분야에서 널리 사용된다:

- 데이터베이스 인덱싱
- 캐시(Cache)
- 중복 제거(Set)
- 라우팅 테이블, 인터프리터 심볼 테이블 등

## 해시테이블의 원리

![해시테이블](/assets/ch9_hash_table/hash_function.png)

                                                                   그림 1. 해시 테이블 기본 구조

### 1. 해시 함수(Hash Function)의 역할

- 해시 테이블의 핵심은 **해싱(Hasing) 매커니즘**에 있다.
- 해시 함수는 키(예: 문자열, 정수 등)를 입력받아 고정된 크기의 **정수값(해시값)**으로 변환한다.
- 이 해시값은 보통 배열의 크기에 대해 **나머지 연산(modulo)**을 수행하여 **최종 인덱스**를 결정한다.

예시:

```c
해시값: 15862
배열 크기: 4
→ 15862 % 4 = 2
→ 인덱스 2번에 데이터 저장
```

---

### 2. 검색(조회) 동작 방식

- 검색 시에도 동일한 해시 함수를 사용하여 인덱스를 재계산한다.
- 해당 위치에 저장된 키와 비교하여 데이터를 확인한다.
- 이때 **충돌 처리 방식**에 따라,
    - 단순 비교로 끝날 수도 있고
    - 체이닝된 리스트나
    - 선형 탐사 등 **다른 슬롯을 순차적으로 탐색**해야 할 수도 있다.

---

### 3. 해시 충돌과 처리 방식

서로 다른 키가 같은 인덱스를 가질 가능성을 **해시 충돌(Collision)**이라 한다.

이를 해결하기 위해 다음과 같은 **충돌 해결 전략**이 사용된다:

### 체이닝 (Chaining)

- 동일한 버킷(인덱스)에 여러 값을 **연결 리스트나 벡터**로 저장한다.
- 충돌된 데이터를 **리스트 형태로 연결**하여 저장하므로 유연하다.

### 개방 주소법 (Open Addressing)

- 충돌이 발생하면 **빈 슬롯을 탐색(Probing)**하여 다른 인덱스에 데이터를 저장한다.
- 탐색 방식에 따라 다음과 같이 나뉜다:
    - **선형 탐사 (Linear Probing)**: +1씩 이동
    - **이차 탐사 (Quadratic Probing)**: +1², +2², +3² …
    - **이중 해싱 (Double Hashing)**: 두 번째 해시 함수로 점프 거리 계산

---

### 4. 해시 테이블의 성능 및 재해싱

- 해시 테이블은 평균적으로 **삽입, 삭제, 검색이 O(1)**의 성능을 제공한다.
- 그러나 **적재율(Load Factor)**이 높아질수록 충돌이 빈번해지고 성능이 저하된다.

> 📌 적재율 = 저장된 데이터 수 / 전체 버킷 수
> 

이를 해결하기 위해 일정 적재율 이상이 되면 다음을 수행한다:

### 재해싱 (Rehashing)

- 테이블 크기를 늘려 새로운 배열을 생성하고,
- 기존 데이터를 **모두 다시 해시하여 재배치**한다.
- 이 과정은 일시적으로 시간이 많이 걸리지만,
**전체적인 평균 시간 복잡도 O(1)**을 유지할 수 있도록 돕는다.

                  

---

## 적재율 (Load Factor) {#load_factor}

해시테이블에서 **적재율(Load Factor, α)**은 저장된 항목의 수를 버킷(bucket) 수로 나눈 비율을 말합니다. 이 값은 해시테이블의 성능과 충돌 가능성을 판단하는 핵심 지표입니다.

- 적재율은 해시 테이블에 저장된 항목의 수를 버킷 수로 나눈 값으로, 다음과 같이 계산된다:
    
    ![적재율](/assets/ch9_hash_table/load_factor.png)
    
- $n$: 현재 저장된 항목의 수 / m: 전체 버킷(bucket) 수

### 적재율의 의미

> 위 그림은 적재율 계산의 기본 원리를 시각적으로 표현한 것으로, 저장된 항목이 많아질수록 충돌 가능성이 높아짐을 보여준다
> 

### 왜 적재율이 중요한가?

- **적재율이 낮을수록** 메모리 사용량은 증가하지만, 충돌 확률이 줄어들어 높은 검색 성능을 유지할 수 있다.
- **적재율이 높아지면** 서로 다른 키가 같은 버킷에 저장될 가능성이 높아지며, 이는 **충돌**로 이어지고 전체 성능을 저하시킨다.

> 즉, 적재율은 해시 테이블의 성능과 메모리 효율성 사이의 균형점을 결정하는 중요한 수치이다
> 

| **적재율(α)** | **의미** 및 **권장 대응** |
| --- | --- |
| **0.0 ~ 0.5** | 매우 여유로운 상태 → 메모리는 많이 사용하지만 충돌은 거의 없음 |
| **0.5 ~ 0.75** | 일반적으로 성능이 좋은 안정 구간 (많은 구현체들이 이 구간을 목표로 함) |
| **0.75 ~ 1.0** | 충돌 가능성 증가 → **리사이징 검토 필요** |
| **1.0 이상** | 대부분의 버킷이 **2개 이상의 항목을 포함** → 성능 급격히 저하됨 |

참조) 적재율 판단 기준 

### 충돌 처리 방식에 따른 적재율 영향

- **개방 주소법 (Open Addressing)**
    - 적재율이 높아질수록 빈 슬롯 찾기가 어려워지며, 성능이 급격히 저하됨
    - 일반적으로 **적재율을 0.7 이하로 유지**하는 것이 바람직하다
- **체이닝 (Chaining)**
    - 한 버킷에 여러 항목을 연결리스트로 저장 → 적재율이 1을 넘어도 동작은 가능
    - 그러나 체인이 길어지면 탐색 시간이 길어지므로, 평균 성능 저하 발생
    
    ### 적재율이 높아지면? → Rehashing
    
    해시테이블은 일정 적재율 임계치(예: 0.75 또는 1.0)를 넘으면 **재해싱(rehashing)** 과정을 수행합니다.
    
    ![image.png](attachment:bdc94900-06e8-45b6-a213-ccf74fedd7d6:image.png)
    
                               그림) 재해싱 과정도표
    
    - **재해싱 과정**
        1. 기존보다 더 큰 테이블을 새로 생성
        2. 모든 데이터를 새로운 해시 함수 기준으로 재배치
        3. 적재율을 낮추고 충돌을 줄여 성능을 회복
    
    > 리해싱은 비용이 큰 연산이지만, 전체적인 평균 성능을 $O(1)$에 가깝게 유지하는 데 핵심적인 역할을 합니다.
    > 

해시테이블의 핵심 구성요소 설명 

  해시테이블은 데이터를 효율적으로 저장하고 관리하기 위해 여러 핵심구성요소가 함께 작동하는 구조이다.

1. 해시함수 

    해시테이블의 핵심요소로 입력 키를 받아 해당키가 저장될 배열의 인덱스(버킷 또는 슬롯)을 계산한다.

    해시함수의 성능은 데이터 분포에 직접적인 영향을 미치기 때문에 매우 중요하다

    좋은해시 함수는 충돌을 최소화하고 데이터를 테이블 전체에 균등하게 분산시켜준다.

1. 버킷 

   해시 테이블에서 데이터를 실제로 저장하는 위치이다. 가장 단순한 형태로는 각 버킷에 키-값 쌍으로

   저장되지만 충돌 처리 전략에 따라 하나의 버킷에 여러 항목이 저장 될 수 있다. 경우에 따라 연결리스트나

   복잡한 구조를 사용할 수 있다.

1. 충돌처리 

   - 서로 다른키가 동일한 인덱스로 해싱되는 현상을 충돌이라 하며 해시 테이블 성능을 유지하려면 

      충돌처리가 중요하다 대표적인 충돌처리 방식은 다음과 같다.

      a. 체이닝(Chaning)

            동일한 인덱스를 공유하는 여러요소를 리스트 등의 자료구조로 연결하여 저장한다. 

            각 버킷은 해당 인덱스를 공유하는 항목들의 연결리스트의 시작지점을 가리킨다.

       b. 개방주소법

            모든요소를 배열 안에 직접 저장한다. 충돌이 발생했을 때는 미리 정의된 규칙에 따라 다양한 버킷을

           탐색한다 대표적인 기법으로 선형탐사, 이차탐사, 이중해싱등이 있다.

- “3,.충돌처리는 나중에 자세하게 다룬다”
## 담당자: 류승찬