# 해시 충돌(Hash Collision)

해시 충돌은 서로 다른 입력 값에 대한 해시함수 동작 결과가 동일한 해시값을 생성하는 현상이다.  
해시 충돌은 해시 함수를 이용한 자료구조나 알고리즘의 효율성을 떨어뜨린다.  
충돌이 많아질수록 해시 테이블의 성능이 O(1)에서 O(n)에 가까워지므로, 해시 충돌이 자주 발생하지 않도록 구성되어야 한다.

만약 해시 테이블 자료구조에서 해시 충돌이 발생한다면 이를 해결해야 하며,
충돌 해결을 위한 대표적인 방법으로는 체이닝(Chaining) 기법과 개방 주소법(Open Addressing)이 있다.


[해시 충돌 시각화 테스트](https://jacti.github.io/web/hash/index.html)


---

## 해시 충돌 해결 방법 자세히 알아보기

### 1. 체이닝(Chaining) 기법

- **원리**:  
  해시 테이블의 각 버킷이 연결 리스트(혹은 다른 자료구조)를 가리키도록 해서, 같은 해시값을 갖는 여러 데이터를 한 버킷에 저장한다.
- **장점**:  
  - 해시 테이블의 크기보다 더 많은 데이터를 저장할 수 있다.
  - 해시 함수가 완벽하지 않아도 충돌을 쉽게 처리할 수 있다.
- **단점**:  
  - 연결 리스트가 길어지면 탐색 속도가 느려질 수 있다.
  - 추가적인 메모리(포인터 등)가 필요하다.
- **예시**:
    ```python
    # 파이썬 딕셔너리 내부 구현과 유사하다
    hash_table = [[] for _ in range(5)]
    def insert(key, value):
        idx = hash(key) % 5
        hash_table[idx].append((key, value))
    ```

---

### 2. 개방 주소법(Open Addressing)

- **원리**:  
  충돌이 발생하면 해시 테이블 내에서 빈 버킷을 찾아 데이터를 저장한다.  
  데이터를 저장할 때, 해시값이 충돌하면 일정한 규칙에 따라 다음 위치를 탐색한다.
- **종류**:
  - **선형 탐사(Linear Probing)**:  
    충돌이 발생하면 한 칸씩 순차적으로 다음 버킷을 검사한다.
  - **이차 탐사(Quadratic Probing)**:  
    충돌이 발생하면 i^2만큼 떨어진 위치를 검사한다.
  - **이중 해싱(Double Hashing)**:  
    두 번째 해시 함수를 사용해 이동할 거리를 결정한다.
- **장점**:  
  - 별도의 연결 리스트가 필요 없어 메모리 사용이 효율적이다.
- **단점**:  
  - 테이블이 꽉 차거나, 충돌이 많아지면 성능이 급격히 저하될 수 있다.
  - 삭제 연산이 복잡해질 수 있다.
- **예시(선형 탐사)**:
    ```python
    size = 5
    hash_table = [None] * size
    def insert(key, value):
        idx = hash(key) % size
        while hash_table[idx] is not None:
            idx = (idx + 1) % size
        hash_table[idx] = (key, value)
    ```

---

이처럼 해시 충돌을 해결하는 방법에는 각각의 장단점이 있으므로, 상황에 맞는 방법을 선택하는 것이 중요하다.